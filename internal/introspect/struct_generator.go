package introspect

import (
	"fmt"
	"strings"
	"time"
)

// StructGenerator generates Go structs from database schema
type StructGenerator struct {
	schema       *DatabaseSchema
	packageName  string
	useDBTags    bool
	useStormTags bool
}

func NewStructGenerator(schema *DatabaseSchema, packageName string) *StructGenerator {
	return &StructGenerator{
		schema:       schema,
		packageName:  packageName,
		useDBTags:    true,
		useStormTags: true,
	}
}

func (g *StructGenerator) GenerateStructs() (string, error) {
	var b strings.Builder

	b.WriteString("//go:build !exclude_generated\n")
	b.WriteString("// +build !exclude_generated\n")
	b.WriteString("\n")

	b.WriteString("// Code generated by db-migrator introspect; DO NOT EDIT.\n")
	b.WriteString("//\n")
	b.WriteString("// This file was automatically generated from the database schema.\n")
	b.WriteString("// Any changes made to this file will be lost when regenerating.\n")
	b.WriteString("//\n")
	b.WriteString("// Source database: " + g.schema.Name + "\n")
	b.WriteString("// Tables found: " + fmt.Sprintf("%d", len(g.schema.Tables)) + "\n")
	b.WriteString("// Generated on: " + time.Now().Format("2006-01-02 15:04:05 MST") + "\n")
	b.WriteString("//\n")
	b.WriteString("// To regenerate this file, run:\n")
	b.WriteString("//   db-migrator introspect --database=\"<connection-url>\" --format=go --package=" + g.packageName + "\n")
	b.WriteString("//\n")
	b.WriteString("// For more information, see:\n")
	b.WriteString("//   https://github.com/eleven-am/storm\n")
	b.WriteString("\n")

	b.WriteString(fmt.Sprintf("package %s\n\n", g.packageName))

	imports := g.collectImports()
	if len(imports) > 0 {
		b.WriteString("import (\n")
		for _, imp := range imports {
			if imp == "github.com/eleven-am/storm/pkg/storm-orm" {
				b.WriteString(fmt.Sprintf("\tstorm \"%s\"\n", imp))
			} else {
				b.WriteString(fmt.Sprintf("\t\"%s\"\n", imp))
			}
		}
		b.WriteString(")\n\n")
	}

	for name, enum := range g.schema.Enums {
		b.WriteString(g.generateEnumType(name, enum))
		b.WriteString("\n")
	}

	for _, table := range sortedTables(g.schema.Tables) {

		if table.PrimaryKey == nil || len(table.PrimaryKey.Columns) == 0 {
			fmt.Printf("Skipping table %s: no primary key defined\n", table.Name)
			continue
		}

		structCode, err := g.generateTableStruct(table)
		if err != nil {
			return "", fmt.Errorf("failed to generate struct for table %s: %w", table.Name, err)
		}
		b.WriteString(structCode)
		b.WriteString("\n")
	}

	return b.String(), nil
}

func (g *StructGenerator) generateTableStruct(table *TableSchema) (string, error) {
	var b strings.Builder

	if table.Comment != "" {
		b.WriteString(fmt.Sprintf("// %s represents the %s table\n", structNameFromTable(table.Name), table.Name))
		b.WriteString(fmt.Sprintf("// %s\n", table.Comment))
	} else {
		b.WriteString(fmt.Sprintf("// %s represents the %s table\n", structNameFromTable(table.Name), table.Name))
	}

	b.WriteString(fmt.Sprintf("type %s struct {\n", structNameFromTable(table.Name)))

	tableDefParts := []string{fmt.Sprintf("table:%s", table.Name)}

	for _, idx := range table.Indexes {
		if !idx.IsPrimary && !idx.IsUnique {
			cols := make([]string, 0)
			for _, c := range idx.Columns {
				if c.Name != "" {
					cols = append(cols, c.Name)
				}
			}
			indexDef := fmt.Sprintf("index:%s,%s", idx.Name, strings.Join(cols, ","))
			if idx.Where != "" {
				indexDef += fmt.Sprintf(" where:%s", idx.Where)
			}
			tableDefParts = append(tableDefParts, indexDef)
		}
	}

	for _, idx := range table.Indexes {
		if idx.IsUnique && !idx.IsPrimary {
			cols := make([]string, 0)
			for _, c := range idx.Columns {
				if c.Name != "" {
					cols = append(cols, c.Name)
				}
			}
			tableDefParts = append(tableDefParts, fmt.Sprintf("unique:%s,%s", idx.Name, strings.Join(cols, ",")))
		}
	}

	for _, c := range table.Constraints {
		if c.Type == "UNIQUE" && len(c.Columns) > 1 {
			tableDefParts = append(tableDefParts, fmt.Sprintf("unique:%s,%s", c.Name, strings.Join(c.Columns, ",")))
		}
	}

	if len(tableDefParts) >= 1 {
		b.WriteString(fmt.Sprintf("\t_ struct{} `storm:\"%s\"`\n", strings.Join(tableDefParts, ";")))
		b.WriteString("\t\n")
	}

	for _, col := range table.Columns {
		fieldDef, err := g.generateField(col, table)
		if err != nil {
			return "", fmt.Errorf("failed to generate field %s: %w", col.Name, err)
		}
		b.WriteString(fieldDef)
	}

	relationshipFields, err := g.generateRelationshipFields(table)
	if err != nil {
		return "", fmt.Errorf("failed to generate relationship fields: %w", err)
	}
	b.WriteString(relationshipFields)

	b.WriteString("}\n")

	return b.String(), nil
}

func (g *StructGenerator) generateRelationshipFields(table *TableSchema) (string, error) {
	var b strings.Builder

	for _, fk := range table.ForeignKeys {
		if len(fk.Columns) == 1 {
			relationshipField, err := g.generateBelongsToRelationship(fk, table)
			if err != nil {
				return "", fmt.Errorf("failed to generate belongs_to relationship for %s: %w", fk.Name, err)
			}
			b.WriteString(relationshipField)
		}
	}

	for _, otherTable := range g.schema.Tables {
		if otherTable.Name == table.Name {
			continue
		}
		for _, fk := range otherTable.ForeignKeys {
			if len(fk.Columns) == 1 && fk.ReferencedTable == table.Name {
				relationshipField, err := g.generateHasManyRelationship(fk, table, otherTable)
				if err != nil {
					return "", fmt.Errorf("failed to generate has_many relationship for %s: %w", fk.Name, err)
				}
				b.WriteString(relationshipField)
			}
		}
	}

	return b.String(), nil
}

func (g *StructGenerator) generateBelongsToRelationship(fk *ForeignKeySchema, table *TableSchema) (string, error) {
	var b strings.Builder

	fieldName := toCamelCase(fk.Columns[0])
	if strings.HasSuffix(fieldName, "Id") {
		fieldName = fieldName[:len(fieldName)-2]
	}

	targetStructName := structNameFromTable(fk.ReferencedTable)

	b.WriteString(fmt.Sprintf("\t%s *%s `storm:\"relation:belongs_to:%s;foreign_key:%s;target_key:%s\"`\n",
		fieldName, targetStructName, targetStructName, fk.Columns[0], fk.ReferencedColumns[0]))

	return b.String(), nil
}

func (g *StructGenerator) generateHasManyRelationship(fk *ForeignKeySchema, currentTable *TableSchema, otherTable *TableSchema) (string, error) {
	var b strings.Builder

	fieldName := pluralize(structNameFromTable(otherTable.Name))

	targetStructName := structNameFromTable(otherTable.Name)

	b.WriteString(fmt.Sprintf("\t%s []%s `storm:\"relation:has_many:%s;foreign_key:%s;source_key:%s\"`\n",
		fieldName, targetStructName, targetStructName, fk.Columns[0], fk.ReferencedColumns[0]))

	return b.String(), nil
}

func (g *StructGenerator) generateField(col *ColumnSchema, table *TableSchema) (string, error) {
	var b strings.Builder

	if col.Comment != "" {
		b.WriteString(fmt.Sprintf("\t// %s\n", col.Comment))
	}

	fieldName := toCamelCase(col.Name)

	goType, err := postgresTypeToGoType(col.DataType, col.UDTName, col.IsNullable)
	if err != nil {
		return "", err
	}

	b.WriteString(fmt.Sprintf("\t%s %s", fieldName, goType))

	var tags []string

	if g.useDBTags {
		tags = append(tags, fmt.Sprintf(`db:"%s"`, col.Name))
	}

	if g.useStormTags {
		stormParts := g.buildStormTag(col, table)
		if len(stormParts) > 0 {
			tags = append(tags, fmt.Sprintf(`storm:"%s"`, strings.Join(stormParts, ";")))
		}
	}

	if len(tags) > 0 {
		b.WriteString(fmt.Sprintf(" `%s`", strings.Join(tags, " ")))
	}

	b.WriteString("\n")

	return b.String(), nil
}

func (g *StructGenerator) buildStormTag(col *ColumnSchema, table *TableSchema) []string {
	var parts []string

	parts = append(parts, fmt.Sprintf("column:%s", col.Name))

	dbType := g.getDBType(col)
	parts = append(parts, fmt.Sprintf("type:%s", dbType))

	if table.PrimaryKey != nil {
		for _, pkCol := range table.PrimaryKey.Columns {
			if pkCol == col.Name {
				parts = append(parts, "primary_key")
				break
			}
		}
	}

	if !col.IsNullable && !isPrimaryKey(col.Name, table) {
		parts = append(parts, "not_null")
	}

	if col.DefaultValue != nil && *col.DefaultValue != "" {

		defaultVal := cleanDefaultValue(*col.DefaultValue)
		if defaultVal != "" {
			parts = append(parts, fmt.Sprintf("default:%s", defaultVal))
		}
	}

	for _, idx := range table.Indexes {
		if idx.IsUnique && !idx.IsPrimary && len(idx.Columns) == 1 && idx.Columns[0].Name == col.Name {
			parts = append(parts, "unique")
			break
		}
	}

	for _, fk := range table.ForeignKeys {
		if len(fk.Columns) == 1 && fk.Columns[0] == col.Name {
			fkDef := fmt.Sprintf("foreign_key:%s.%s", fk.ReferencedTable, fk.ReferencedColumns[0])
			parts = append(parts, fkDef)

			if fk.OnDelete != "NO ACTION" && fk.OnDelete != "" {
				parts = append(parts, fmt.Sprintf("on_delete:%s", fk.OnDelete))
			}
			if fk.OnUpdate != "NO ACTION" && fk.OnUpdate != "" {
				parts = append(parts, fmt.Sprintf("on_update:%s", fk.OnUpdate))
			}
			break
		}
	}

	return parts
}

func (g *StructGenerator) getDBType(col *ColumnSchema) string {

	if col.DataType == "USER-DEFINED" && col.UDTName != "" {
		return col.UDTName
	}

	if strings.HasPrefix(col.DataType, "ARRAY") || strings.HasSuffix(col.DataType, "[]") {
		baseType := col.UDTName
		if strings.HasPrefix(baseType, "_") {
			baseType = baseType[1:]
		}
		return baseType + "[]"
	}

	switch col.DataType {
	case "character varying":
		if col.CharMaxLength != nil {
			return fmt.Sprintf("varchar(%d)", *col.CharMaxLength)
		}
		return "varchar"
	case "character":
		if col.CharMaxLength != nil {
			return fmt.Sprintf("char(%d)", *col.CharMaxLength)
		}
		return "char"
	case "text":
		return "text"
	case "integer":
		return "integer"
	case "bigint":
		return "bigint"
	case "smallint":
		return "smallint"
	case "numeric":
		if col.NumericPrecision != nil && col.NumericScale != nil {
			return fmt.Sprintf("numeric(%d,%d)", *col.NumericPrecision, *col.NumericScale)
		}
		return "numeric"
	case "real":
		return "real"
	case "double precision":
		return "double precision"
	case "boolean":
		return "boolean"
	case "timestamp with time zone":
		return "timestamptz"
	case "timestamp without time zone":
		return "timestamp"
	case "date":
		return "date"
	case "time with time zone":
		return "timetz"
	case "time without time zone":
		return "time"
	case "interval":
		return "interval"
	case "uuid":
		return "uuid"
	case "json":
		return "json"
	case "jsonb":
		return "jsonb"
	case "bytea":
		return "bytea"
	default:

		return col.DataType
	}
}

func postgresTypeToGoType(dataType, udtName string, isNullable bool) (string, error) {
	var goType string

	if strings.HasPrefix(dataType, "ARRAY") || strings.HasSuffix(dataType, "[]") {
		baseType := udtName
		if strings.HasPrefix(baseType, "_") {
			baseType = baseType[1:]
		}

		switch baseType {
		case "text", "character varying", "character", "varchar":
			goType = "storm.StringArray"
		default:
			elementType, err := postgresTypeToGoType(baseType, "", false)
			if err != nil {
				return "", err
			}
			goType = "[]" + elementType
		}
	} else {

		switch dataType {
		case "character varying", "character", "text":
			goType = "string"
		case "integer":
			goType = "int32"
		case "bigint":
			goType = "int64"
		case "smallint":
			goType = "int16"
		case "numeric", "decimal":
			goType = "float64"
		case "real":
			goType = "float32"
		case "double precision":
			goType = "float64"
		case "boolean":
			goType = "bool"
		case "timestamp with time zone", "timestamp without time zone":
			goType = "time.Time"
		case "date":
			goType = "time.Time"
		case "time with time zone", "time without time zone":
			goType = "time.Time"
		case "interval":
			goType = "time.Duration"
		case "uuid":
			goType = "string"
		case "json", "jsonb":
			goType = "storm.JSONData"
		case "bytea":
			goType = "[]byte"
		case "USER-DEFINED":

			goType = "string"
		default:

			goType = "string"
		}
	}

	if isNullable && !strings.HasPrefix(goType, "[]") && goType != "storm.StringArray" {
		goType = "*" + goType
	}

	return goType, nil
}

func structNameFromTable(tableName string) string {

	parts := strings.Split(tableName, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}

	name := strings.Join(parts, "")
	if strings.HasSuffix(name, "ies") {
		name = name[:len(name)-3] + "y"
	} else if strings.HasSuffix(name, "ses") || strings.HasSuffix(name, "xes") || strings.HasSuffix(name, "zes") {
		name = name[:len(name)-2]
	} else if strings.HasSuffix(name, "s") && !strings.HasSuffix(name, "ss") {
		name = name[:len(name)-1]
	}

	return name
}

func toCamelCase(s string) string {
	parts := strings.Split(s, "_")
	for i := range parts {
		parts[i] = strings.Title(parts[i])
	}
	return strings.Join(parts, "")
}

func isPrimaryKey(colName string, table *TableSchema) bool {
	if table.PrimaryKey == nil {
		return false
	}
	for _, pk := range table.PrimaryKey.Columns {
		if pk == colName {
			return true
		}
	}
	return false
}

func cleanDefaultValue(defaultVal string) string {

	defaultVal = strings.TrimSpace(defaultVal)

	if defaultVal == "NULL" {
		return ""
	}

	if idx := strings.Index(defaultVal, "::"); idx != -1 {
		defaultVal = defaultVal[:idx]
	}

	if strings.HasPrefix(defaultVal, "'") && strings.HasSuffix(defaultVal, "'") {
		defaultVal = defaultVal[1 : len(defaultVal)-1]
	}

	if strings.Contains(defaultVal, "(") {
		return defaultVal
	}

	if _, err := fmt.Sscanf(defaultVal, "%d", new(int)); err != nil {
		if _, err := fmt.Sscanf(defaultVal, "%f", new(float64)); err != nil {
			if defaultVal != "true" && defaultVal != "false" {
				return fmt.Sprintf("'%s'", defaultVal)
			}
		}
	}

	return defaultVal
}

func (g *StructGenerator) collectImports() []string {
	imports := make(map[string]bool)

	for _, table := range g.schema.Tables {
		for _, col := range table.Columns {
			if strings.Contains(col.DataType, "time") || col.DataType == "date" {
				imports["time"] = true
			}
			if col.DataType == "json" || col.DataType == "jsonb" {
				imports["github.com/eleven-am/storm/pkg/storm-orm"] = true
			}

			if strings.HasPrefix(col.DataType, "ARRAY") || strings.HasSuffix(col.DataType, "[]") {
				baseType := col.UDTName
				if strings.HasPrefix(baseType, "_") {
					baseType = baseType[1:]
				}
				switch baseType {
				case "text", "character varying", "character", "varchar":
					imports["github.com/eleven-am/storm/pkg/storm-orm"] = true
				}
			}
		}
	}

	var result []string
	for imp := range imports {
		result = append(result, imp)
	}

	for i := 0; i < len(result); i++ {
		for j := i + 1; j < len(result); j++ {
			if result[i] > result[j] {
				result[i], result[j] = result[j], result[i]
			}
		}
	}

	return result
}

func (g *StructGenerator) generateEnumType(name string, enum *EnumSchema) string {
	var b strings.Builder

	enumName := name
	if dotIdx := strings.LastIndex(name, "."); dotIdx > 0 {
		enumName = name[dotIdx+1:]
	}

	typeName := toCamelCase(enumName)

	b.WriteString(fmt.Sprintf("// %s represents the %s enum type\n", typeName, name))
	b.WriteString(fmt.Sprintf("type %s string\n\n", typeName))

	b.WriteString("const (\n")
	for _, value := range enum.Values {
		constName := fmt.Sprintf("%s%s", typeName, toCamelCase(value))
		b.WriteString(fmt.Sprintf("\t%s %s = \"%s\"\n", constName, typeName, value))
	}
	b.WriteString(")\n")

	return b.String()
}

func pluralize(s string) string {
	lower := strings.ToLower(s)
	if lower == "category" {
		return s[:len(s)-1] + "ies"
	}

	if strings.HasSuffix(s, "y") && !strings.HasSuffix(s, "ey") {
		return s[:len(s)-1] + "ies"
	}
	if strings.HasSuffix(s, "s") || strings.HasSuffix(s, "sh") ||
		strings.HasSuffix(s, "ch") || strings.HasSuffix(s, "x") {
		return s + "es"
	}
	return s + "s"
}
