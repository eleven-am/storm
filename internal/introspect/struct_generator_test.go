package introspect

import (
	"strings"
	"testing"
	"time"
)

func TestStructGenerator_GenerateStructs(t *testing.T) {

	schema := &DatabaseSchema{
		Name: "test_db",
		Tables: map[string]*TableSchema{
			"users": {
				Name:   "users",
				Schema: "public",
				Columns: []*ColumnSchema{
					{
						Name:         "id",
						DataType:     "uuid",
						IsNullable:   false,
						DefaultValue: stringPtr("gen_random_uuid()"),
					},
					{
						Name:          "email",
						DataType:      "character varying",
						CharMaxLength: intPtr(255),
						IsNullable:    false,
					},
					{
						Name:         "created_at",
						DataType:     "timestamp with time zone",
						IsNullable:   false,
						DefaultValue: stringPtr("now()"),
					},
				},
				PrimaryKey: &PrimaryKeySchema{
					Name:    "users_pkey",
					Columns: []string{"id"},
				},
				Indexes: []*IndexSchema{
					{
						Name:      "idx_users_email",
						Columns:   []IndexColumn{{Name: "email"}},
						IsUnique:  true,
						IsPrimary: false,
					},
				},
			},
		},
		Metadata: DatabaseMetadata{
			InspectedAt: time.Now(),
			TableCount:  1,
		},
	}

	generator := NewStructGenerator(schema, "models")
	result, err := generator.GenerateStructs()
	if err != nil {
		t.Fatalf("Failed to generate structs: %v", err)
	}

	expectedContents := []string{
		"package models",
		"Code generated by db-migrator introspect; DO NOT EDIT",
		"type User struct",
		"Id string",
		"type:uuid;primary_key;default:gen_random_uuid()",
		"Email string",
		"type:varchar(255);not_null;unique",
		"CreatedAt time.Time",
		"type:timestamptz;not_null;default:now()",
		"import (",
		`"time"`,
		"table:users",
		"unique:idx_users_email,email",
	}

	for _, expected := range expectedContents {
		if !strings.Contains(result, expected) {
			t.Errorf("Expected generated code to contain %q, but it didn't.\nGenerated:\n%s", expected, result)
		}
	}
}

func TestStructGenerator_ComplexTypes(t *testing.T) {
	schema := &DatabaseSchema{
		Name: "test_db",
		Tables: map[string]*TableSchema{
			"complex_types": {
				Name:   "complex_types",
				Schema: "public",
				Columns: []*ColumnSchema{
					{
						Name:       "id",
						DataType:   "integer",
						IsNullable: false,
					},
					{
						Name:       "tags",
						DataType:   "ARRAY",
						UDTName:    "_text",
						IsNullable: false,
					},
					{
						Name:       "metadata",
						DataType:   "jsonb",
						IsNullable: true,
					},
					{
						Name:       "status",
						DataType:   "USER-DEFINED",
						UDTName:    "order_status",
						IsNullable: false,
					},
					{
						Name:             "amount",
						DataType:         "numeric",
						IsNullable:       true,
						NumericPrecision: intPtr(10),
						NumericScale:     intPtr(2),
					},
				},
				PrimaryKey: &PrimaryKeySchema{
					Name:    "complex_types_pkey",
					Columns: []string{"id"},
				},
			},
		},
		Enums: map[string]*EnumSchema{
			"public.order_status": {
				Name:   "order_status",
				Schema: "public",
				Values: []string{"pending", "processing", "completed", "cancelled"},
			},
		},
	}

	generator := NewStructGenerator(schema, "models")
	result, err := generator.GenerateStructs()
	if err != nil {
		t.Fatalf("Failed to generate structs: %v", err)
	}

	expectedContents := []string{
		`"github.com/eleven-am/storm/pkg/storm-orm"`,
		"type ComplexType struct",
		"Id int32",
		"type:integer;primary_key",
		"Tags storm.StringArray",
		"type:text[];not_null",
		"Metadata *storm.JSONData",
		"type:jsonb",
		"Status string",
		"type:order_status;not_null",
		"Amount *float64",
		"type:numeric(10,2)",
		"type OrderStatus string",
		`OrderStatusPending OrderStatus = "pending"`,
		`OrderStatusProcessing OrderStatus = "processing"`,
		`OrderStatusCompleted OrderStatus = "completed"`,
		`OrderStatusCancelled OrderStatus = "cancelled"`,
	}

	for _, expected := range expectedContents {
		if !strings.Contains(result, expected) {
			t.Errorf("Expected generated code to contain %q, but it didn't.\nGenerated:\n%s", expected, result)
		}
	}
}

func TestStructGenerator_ForeignKeys(t *testing.T) {
	schema := &DatabaseSchema{
		Name: "test_db",
		Tables: map[string]*TableSchema{
			"orders": {
				Name:   "orders",
				Schema: "public",
				Columns: []*ColumnSchema{
					{
						Name:         "id",
						DataType:     "uuid",
						IsNullable:   false,
						DefaultValue: stringPtr("gen_random_uuid()"),
					},
					{
						Name:       "user_id",
						DataType:   "uuid",
						IsNullable: false,
					},
					{
						Name:       "product_id",
						DataType:   "uuid",
						IsNullable: true,
					},
				},
				PrimaryKey: &PrimaryKeySchema{
					Name:    "orders_pkey",
					Columns: []string{"id"},
				},
				ForeignKeys: []*ForeignKeySchema{
					{
						Name:              "fk_orders_user",
						Columns:           []string{"user_id"},
						ReferencedTable:   "users",
						ReferencedColumns: []string{"id"},
						OnDelete:          "CASCADE",
						OnUpdate:          "RESTRICT",
					},
					{
						Name:              "fk_orders_product",
						Columns:           []string{"product_id"},
						ReferencedTable:   "products",
						ReferencedColumns: []string{"id"},
						OnDelete:          "SET NULL",
						OnUpdate:          "NO ACTION",
					},
				},
			},
		},
	}

	generator := NewStructGenerator(schema, "models")
	result, err := generator.GenerateStructs()
	if err != nil {
		t.Fatalf("Failed to generate structs: %v", err)
	}

	expectedContents := []string{
		"UserId string",
		"type:uuid;not_null;foreign_key:users.id;on_delete:CASCADE;on_update:RESTRICT",
		"ProductId *string",
		"type:uuid;foreign_key:products.id;on_delete:SET NULL",
	}

	for _, expected := range expectedContents {
		if !strings.Contains(result, expected) {
			t.Errorf("Expected generated code to contain %q, but it didn't.\nGenerated:\n%s", expected, result)
		}
	}
}

func TestStructGenerator_TableNameConversion(t *testing.T) {
	tests := []struct {
		tableName    string
		expectedName string
	}{
		{"users", "User"},
		{"user_profiles", "UserProfile"},
		{"categories", "Category"},
		{"companies", "Company"},
		{"addresses", "Address"},
		{"statuses", "Status"},
		{"boxes", "Box"},
		{"buzzes", "Buzz"},
	}

	for _, tt := range tests {
		result := structNameFromTable(tt.tableName)
		if result != tt.expectedName {
			t.Errorf("structNameFromTable(%q) = %q, want %q", tt.tableName, result, tt.expectedName)
		}
	}
}

func TestPostgresTypeToGoType(t *testing.T) {
	tests := []struct {
		dataType   string
		udtName    string
		isNullable bool
		expected   string
	}{
		{"character varying", "", false, "string"},
		{"character varying", "", true, "*string"},
		{"integer", "", false, "int32"},
		{"integer", "", true, "*int32"},
		{"bigint", "", false, "int64"},
		{"bigint", "", true, "*int64"},
		{"boolean", "", false, "bool"},
		{"boolean", "", true, "*bool"},
		{"timestamp with time zone", "", false, "time.Time"},
		{"timestamp with time zone", "", true, "*time.Time"},
		{"jsonb", "", false, "storm.JSONData"},
		{"jsonb", "", true, "*storm.JSONData"},
		{"ARRAY", "_text", false, "storm.StringArray"},
		{"ARRAY", "_text", true, "storm.StringArray"},
		{"uuid", "", false, "string"},
		{"uuid", "", true, "*string"},
		{"bytea", "", false, "[]byte"},
		{"bytea", "", true, "[]byte"},
		{"USER-DEFINED", "custom_type", false, "string"},
		{"USER-DEFINED", "custom_type", true, "*string"},
	}

	for _, tt := range tests {
		result, err := postgresTypeToGoType(tt.dataType, tt.udtName, tt.isNullable)
		if err != nil {
			t.Errorf("postgresTypeToGoType(%q, %q, %v) returned error: %v", tt.dataType, tt.udtName, tt.isNullable, err)
			continue
		}
		if result != tt.expected {
			t.Errorf("postgresTypeToGoType(%q, %q, %v) = %q, want %q", tt.dataType, tt.udtName, tt.isNullable, result, tt.expected)
		}
	}
}

// Helper functions
func stringPtr(s string) *string {
	return &s
}

func intPtr(i int) *int {
	return &i
}
