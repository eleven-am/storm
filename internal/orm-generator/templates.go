package orm_generator

// metadataTemplate generates compile-time metadata for models
const metadataTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Model: {{ .Model.Name }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	{{- if .Model.Relationships }}
	"context"
	{{- end }}
	storm "github.com/eleven-am/storm/pkg/storm-orm"
)

// {{ .Model.Name }}Metadata provides compile-time metadata for {{ .Model.Name }}
var {{ .Model.Name }}Metadata = &storm.ModelMetadata{
	TableName:  "{{ .Model.TableName }}",
	StructName: "{{ .Model.Name }}",
	
	Columns: map[string]*storm.ColumnMetadata{
		{{- range .Model.Columns }}
		"{{ .Name }}": {
			FieldName:       "{{ .Name }}",
			DBName:          "{{ .DBName }}",
			GoType:          "{{ .Type }}",
			IsPointer:       {{ .IsPointer }},
			IsPrimaryKey:    {{ .IsPrimaryKey }},
			IsAutoGenerated: {{ .IsAutoGenerated }},
			
			// Generated accessor functions for zero-reflection field access
			GetValue: func(model interface{}) interface{} {
				m := model.({{ $.Model.Name }})
				{{- if .IsPointer }}
				if m.{{ .Name }} != nil {
					return *m.{{ .Name }}
				}
				return nil
				{{- else }}
				return m.{{ .Name }}
				{{- end }}
			},
			{{- if .IsPointer }}
			IsNil: func(model interface{}) bool {
				return model.({{ $.Model.Name }}).{{ .Name }} == nil
			},
			{{- end }}
		},
		{{- end }}
	},
	
	ColumnMap: map[string]string{
		{{- range .Model.Columns }}
		"{{ .Name }}": "{{ .DBName }}",
		{{- end }}
	},
	
	ReverseMap: map[string]string{
		{{- range .Model.Columns }}
		"{{ .DBName }}": "{{ .Name }}",
		{{- end }}
	},
	
	PrimaryKeys: []string{
		{{- range .Model.PrimaryKeys }}
		"{{ . }}",
		{{- end }}
	},
	
	Relationships: map[string]*storm.RelationshipMetadata{
		{{- range .Model.Relationships }}
		"{{ .Name }}": {
			Name:   "{{ .Name }}",
			Type:   "{{ .Relationship.Type }}",
			Target: "{{ .Relationship.Target }}",
			{{- if index $.ModelTableMap .Relationship.Target }}
			TargetTable: "{{ index $.ModelTableMap .Relationship.Target }}",
			{{- end }}
			{{- if .Relationship.ForeignKey }}
			ForeignKey: "{{ .Relationship.ForeignKey }}",
			{{- end }}
			{{- if .Relationship.SourceKey }}
			SourceKey: "{{ .Relationship.SourceKey }}",
			{{- end }}
			{{- if .Relationship.TargetKey }}
			TargetKey: "{{ .Relationship.TargetKey }}",
			{{- end }}
			{{- if .Relationship.Through }}
			Through: "{{ .Relationship.Through }}",
			{{- end }}
			{{- if .Relationship.SourceFK }}
			ThroughFK: "{{ .Relationship.SourceFK }}",
			{{- end }}
			{{- if .Relationship.TargetFK }}
			ThroughTK: "{{ .Relationship.TargetFK }}",
			{{- end }}
			
			// Zero-reflection relationship scanning - directly scan and set on model
			ScanToModel: func(ctx context.Context, exec storm.DBExecutor, query string, args []interface{}, model interface{}) error {
				{{- if or (eq .Relationship.Type "has_many") (eq .Relationship.Type "has_many_through") }}
				var {{ lower .Name }} []{{ .Relationship.Target }}
				err := exec.SelectContext(ctx, &{{ lower .Name }}, query, args...)
				if err != nil {
					return err
				}
				model.(*{{ $.Model.Name }}).{{ .Name }} = {{ lower .Name }}
				{{- else if or (eq .Relationship.Type "has_one") (eq .Relationship.Type "belongs_to") }}
				var {{ lower .Name }} {{ .Relationship.Target }}
				err := exec.GetContext(ctx, &{{ lower .Name }}, query, args...)
				if err != nil {
					return err
				}
				{{- if .IsPointer }}
				model.(*{{ $.Model.Name }}).{{ .Name }} = &{{ lower .Name }}
				{{- else }}
				model.(*{{ $.Model.Name }}).{{ .Name }} = {{ lower .Name }}
				{{- end }}
				{{- end }}
				return nil
			},
		},
		{{- end }}
	},
}
`

// columnTemplate generates type-safe column constants
const columnTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Models found: {{ len .Models }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"time"
	storm "github.com/eleven-am/storm/pkg/storm-orm"
)

{{range $modelName, $model := .Models}}
// {{ $model.Name }}s provides type-safe column references for {{ $model.Name }}
var {{ $model.Name }}s = struct {
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }} {{ if eq .Type "string" }}storm.StringColumn{{ else if eq .Type "int" }}storm.NumericColumn[int]{{ else if eq .Type "int32" }}storm.NumericColumn[int32]{{ else if eq .Type "int64" }}storm.NumericColumn[int64]{{ else if eq .Type "float32" }}storm.NumericColumn[float32]{{ else if eq .Type "float64" }}storm.NumericColumn[float64]{{ else if eq .Type "bool" }}storm.BoolColumn{{ else if eq .Type "time.Time" }}storm.TimeColumn{{ else if eq .Type "storm.StringArray" }}storm.ArrayColumn[string]{{ else if hasPrefix .Type "[]" }}storm.ArrayColumn[{{ .Type }}]{{ else if eq .Type "json.RawMessage" }}storm.JSONBColumn{{ else if eq .Type "storm.JSONData" }}storm.JSONBColumn{{ else if hasPrefix .Type "JSONField[" }}storm.JSONBColumn{{ else if eq .Type "" }}storm.StringColumn{{ else }}storm.Column[interface{}]{{ end }} ` + "`json:\"{{ .DBName }}\"`" + `
	{{end}}
}{
	{{range $model.Columns}}
	{{ sanitizeGoName .Name }}: {{ if eq .Type "string" }}storm.StringColumn{Column: storm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "int" }}storm.NumericColumn[int]{ComparableColumn: storm.ComparableColumn[int]{Column: storm.Column[int]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int32" }}storm.NumericColumn[int32]{ComparableColumn: storm.ComparableColumn[int32]{Column: storm.Column[int32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "int64" }}storm.NumericColumn[int64]{ComparableColumn: storm.ComparableColumn[int64]{Column: storm.Column[int64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float32" }}storm.NumericColumn[float32]{ComparableColumn: storm.ComparableColumn[float32]{Column: storm.Column[float32]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "float64" }}storm.NumericColumn[float64]{ComparableColumn: storm.ComparableColumn[float64]{Column: storm.Column[float64]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "bool" }}storm.BoolColumn{Column: storm.Column[bool]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "time.Time" }}storm.TimeColumn{ComparableColumn: storm.ComparableColumn[time.Time]{Column: storm.Column[time.Time]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}}{{ else if eq .Type "storm.StringArray" }}storm.ArrayColumn[string]{Column: storm.Column[[]string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if hasPrefix .Type "[]" }}storm.ArrayColumn[{{ .Type }}]{Column: storm.Column[{{ .Type }}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "json.RawMessage" }}storm.JSONBColumn{Column: storm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "storm.JSONData" }}storm.JSONBColumn{Column: storm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if hasPrefix .Type "JSONField[" }}storm.JSONBColumn{Column: storm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else if eq .Type "" }}storm.StringColumn{Column: storm.Column[string]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}}{{ else }}storm.Column[interface{}]{Name: "{{ .DBName }}", Table: "{{ $model.TableName }}"}{{ end }},
	{{end}}
}

// {{ $model.Name }}Table provides table-level operations for {{ $model.Name }}
var {{ $model.Name }}Table = storm.Table{
	Name: "{{ $model.TableName }}",
	PrimaryKeys: []string{ {{ range $model.PrimaryKeys }}"{{ . }}", {{ end }} },
}

{{end}}
`

// repositoryTemplate generates repository implementations
const repositoryTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Model: {{ .Model.Name }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"context"
	"fmt"
	storm "github.com/eleven-am/storm/pkg/storm-orm"
	"github.com/jmoiron/sqlx"
)

// {{ .Model.Name }}Repository provides type-safe operations for {{ .Model.Name }}
//
// The repository inherits these operations from storm.Repository:
//
// Single Record Operations:
//   - Create(ctx, record) - Insert single record, returns saved record
//   - FindByID(ctx, id) - Find record by primary key
//   - Update(ctx, record) - Update single record by primary key, returns updated record
//   - Delete(ctx, id) - Delete record by primary key ID, returns deleted record
//   - DeleteRecord(ctx, record) - Delete record using the record instance, returns deleted record
//
// Batch Operations:
//   - CreateMany(ctx, records) - Insert multiple records in transaction
//   - BulkUpdate(ctx, records, opts) - Update multiple records with bulk operation
//   - Upsert(ctx, record, opts) - Insert or update single record on conflict
//   - UpsertMany(ctx, records, opts) - Insert or update multiple records on conflict
//
// Query Building:
//   - Query(ctx) - Create new query builder for complex queries
//
// Example usage:
//   // Single operations
//   {{ lower .Model.Name }}, err := repo.FindByID(ctx, "123")
//   saved{{ .Model.Name }}, err := repo.Create(ctx, &new{{ .Model.Name }})
//   updated{{ .Model.Name }}, err := repo.Update(ctx, &existing{{ .Model.Name }})
//   deleted{{ .Model.Name }}, err := repo.Delete(ctx, "123")
//   
//   // Batch operations
//   err = repo.CreateMany(ctx, multiple{{ .Model.Name }}s)
//   rowsAffected, err := repo.BulkUpdate(ctx, records, opts)
//   err = repo.Upsert(ctx, record, opts)
//   
//   // Complex queries and operations
//   results, err := repo.Query(ctx).Where(condition).OrderBy("created_at DESC").Find()
//   rowsAffected, err := repo.Query(ctx).Where(condition).Delete()
type {{ .Model.Name }}Repository struct {
	*storm.Repository[{{ .Model.Name }}]
}

func new{{ .Model.Name }}Repository(db *sqlx.DB) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := storm.NewRepository[{{ .Model.Name }}](db, {{ .Model.Name }}Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

func new{{ .Model.Name }}RepositoryWithTx(tx *sqlx.Tx) (*{{ .Model.Name }}Repository, error) {
	baseRepo, err := storm.NewRepositoryWithTx[{{ .Model.Name }}](tx, {{ .Model.Name }}Metadata)
	if err != nil {
		return nil, fmt.Errorf("failed to create base repository with transaction: %w", err)
	}

	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}, nil
}

// Query returns a type-safe query builder for {{ .Model.Name }}
//
// Example:
{{- $firstStringField := "" }}
{{- $firstBoolField := "" }}
{{- $firstTimeField := "" }}
{{- $primaryKeyField := "" }}
{{- range .Model.Columns }}
{{- if and (eq .Type "string") (eq $firstStringField "") (not .IsPrimaryKey) }}{{ $firstStringField = .Name }}{{ end }}
{{- if and (eq .Type "bool") (eq $firstBoolField "") }}{{ $firstBoolField = .Name }}{{ end }}
{{- if and (eq .Type "time.Time") (eq $firstTimeField "") (not (contains .Name "At")) }}{{ $firstTimeField = .Name }}{{ end }}
{{- if and .IsPrimaryKey (eq $primaryKeyField "") }}{{ $primaryKeyField = .Name }}{{ end }}
{{- end }}
{{- if $firstBoolField }}
//   active{{ .Model.Name }}s, err := repo.Query(ctx).
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).
{{- else if $firstStringField }}
//   filtered{{ .Model.Name }}s, err := repo.Query(ctx).
//       Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).
{{- else }}
//   all{{ .Model.Name }}s, err := repo.Query(ctx).
{{- end }}
{{- if $firstTimeField }}
//       OrderBy({{ .Model.Name }}s.{{ sanitizeGoName $firstTimeField }}.Desc()).
{{- else if $primaryKeyField }}
//       OrderBy({{ .Model.Name }}s.{{ sanitizeGoName $primaryKeyField }}.Desc()).
{{- else }}
//       OrderBy("id DESC").
{{- end }}
func (r *{{ .Model.Name }}Repository) Query(ctx context.Context) *{{ .Model.Name }}Query {
	return &{{ .Model.Name }}Query{
		Query: r.Repository.Query(ctx),
		repo:  r,
	}
}

// Authorize returns a new Repository instance with type-safe authorization
// The authorization function receives the type-safe query and returns a modified query
//
// Example:
//   authorizedRepo := repo.Authorize(func(ctx context.Context, query *{{ .Model.Name }}Query) *{{ .Model.Name }}Query {
//       user := ctx.Value("user").(AuthUser)
//       return query.Where({{ .Model.Name }}s.TeamId.Eq(user.TeamID))
//   })
//   users, err := authorizedRepo.Query(ctx).Find()
func (r *{{ .Model.Name }}Repository) Authorize(fn func(ctx context.Context, query *{{ .Model.Name }}Query) *{{ .Model.Name }}Query) *{{ .Model.Name }}Repository {
	genericFn := func(ctx context.Context, query *storm.Query[{{ .Model.Name }}]) *storm.Query[{{ .Model.Name }}] {
		{{ lower .Model.Name }}Query := &{{ .Model.Name }}Query{
			Query: query,
			repo:  r,
		}
		result := fn(ctx, {{ lower .Model.Name }}Query)
		return result.Query
	}
	
	// Call the base Repository.Authorize with the converted function
	baseRepo := r.Repository.Authorize(genericFn)
	
	// Return a new {{ .Model.Name }}Repository wrapping the authorized base repository
	return &{{ .Model.Name }}Repository{
		Repository: baseRepo,
	}
}

// {{ .Model.Name }}Query provides type-safe query building for {{ .Model.Name }}
//
// Query Methods (returned by Query(ctx)):
//   - Where(condition) - Add WHERE conditions
//   - OrderBy(expressions...) - Add ORDER BY
//   - Limit(limit) - Set LIMIT
//   - Offset(offset) - Set OFFSET
//   - Join(type, table, condition) - Generic join
//   - InnerJoin(table, condition) - Inner join
//   - LeftJoin(table, condition) - Left join
//   - RightJoin(table, condition) - Right join
//   - FullJoin(table, condition) - Full outer join
//   - Include(relationships...) - Load relationships
//   - IncludeWhere(relationship, conditions...) - Load relationships with conditions
//   - WithTx(tx) - Execute within transaction
//
// Execution Methods:
//   - Find() - Execute query and return all records
//   - First() - Execute query and return first record
//   - Count() - Execute count query
//   - Exists() - Check if any records exist
//   - Delete() - Execute DELETE query
//   - ExecuteRaw(query, args...) - Execute raw SQL
//
// Example usage:
//   // Simple query
//   results, err := repo.Query(ctx).Where({{ .Model.Name }}s.FieldName.Eq("value")).Find()
//   
//   // Complex query with joins and ordering
//   results, err := repo.Query(ctx).
//       Where(condition).
//       OrderBy("created_at DESC").
//       Limit(10).
//       Find()
//   
//   // Query with relationships
//   results, err := repo.Query(ctx).
//       Include("RelationshipName").
//       Where(condition).
//       Find()
type {{ .Model.Name }}Query struct {
	*storm.Query[{{ .Model.Name }}]
	repo *{{ .Model.Name }}Repository
}

// Where applies a filtering condition to the query.
// Use the type-safe column references from {{ .Model.Name }}s for conditions.
//
// Examples:
{{- $firstStringField := "" }}
{{- $firstBoolField := "" }}
{{- $firstNumericField := "" }}
{{- $firstTimeField := "" }}
{{- range .Model.Columns }}
{{- if and (eq .Type "string") (eq $firstStringField "") (not .IsPrimaryKey) }}{{ $firstStringField = .Name }}{{ end }}
{{- if and (eq .Type "bool") (eq $firstBoolField "") }}{{ $firstBoolField = .Name }}{{ end }}
{{- if and (or (eq .Type "int") (eq .Type "int32") (eq .Type "int64")) (eq $firstNumericField "") }}{{ $firstNumericField = .Name }}{{ end }}
{{- if and (eq .Type "time.Time") (eq $firstTimeField "") }}{{ $firstTimeField = .Name }}{{ end }}
{{- end }}
{{- if $firstStringField }}
//   // Exact match
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Eq("exact-value"))
//   // Pattern matching
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%"))
//   // Multiple values
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.In([]string{"value1", "value2"}))
{{- end }}
{{- if $firstBoolField }}
//   // Boolean condition
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true))
{{- end }}
{{- if $firstNumericField }}
//   // Numeric comparisons
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstNumericField }}.Gt(100))
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstNumericField }}.Between(10, 50))
{{- end }}
{{- if $firstTimeField }}
//   // Time-based queries
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName $firstTimeField }}.After(time.Now().AddDate(0, -1, 0)))
{{- end }}
//   // Combine conditions
//   query.Where({{ .Model.Name }}s.{{ sanitizeGoName (index .Model.Columns 0).Name }}.Eq("value").And({{ .Model.Name }}s.{{ sanitizeGoName (index .Model.Columns 1).Name }}.IsNotNull()))
func (q *{{ .Model.Name }}Query) Where(condition storm.Condition) *{{ .Model.Name }}Query {
	q.Query = q.Query.Where(condition)
	return q
}

// OrderBy specifies the order of results using column names or expressions.
// Use DESC suffix for descending order, ASC (or no suffix) for ascending.
//
// Examples:
{{- if $firstTimeField }}
//   // Order by time field (most recent first)
//   query.OrderBy("{{ (index .Model.Columns 0).DBName }} DESC")
{{- end }}
{{- if $firstStringField }}
//   // Order by string field alphabetically
//   query.OrderBy("{{ (index .Model.Columns 0).DBName }}")
{{- end }}
//   // Multiple columns
//   query.OrderBy("{{ (index .Model.Columns 0).DBName }} DESC", "{{ (index .Model.Columns 1).DBName }}")
//   // Complex expressions
//   query.OrderBy("CASE WHEN active THEN 0 ELSE 1 END", "created_at DESC")
func (q *{{ .Model.Name }}Query) OrderBy(expressions ...string) *{{ .Model.Name }}Query {
	q.Query = q.Query.OrderBy(expressions...)
	return q
}

// Limit restricts the number of results returned.
// Useful for pagination and preventing large result sets.
//
// Examples:
//   // Get first 10 results
//   query.Limit(10)
//   // Get top 100 most recent {{ lower .Model.Name }}s
//   query.OrderBy("created_at DESC").Limit(100)
func (q *{{ .Model.Name }}Query) Limit(limit uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Limit(limit)
	return q
}

// Offset skips the specified number of results.
// Typically used with Limit for pagination.
//
// Examples:
//   // Skip first 20 results (page 3 with 10 per page)
//   query.Offset(20).Limit(10)
//   // Get results 51-100
//   query.Offset(50).Limit(50)
func (q *{{ .Model.Name }}Query) Offset(offset uint64) *{{ .Model.Name }}Query {
	q.Query = q.Query.Offset(offset)
	return q
}

// Find executes the query and returns all matching {{ .Model.Name }} records.
// Returns an empty slice if no records are found.
//
// Examples:
//   // Get all {{ lower .Model.Name }}s
//   all{{ .Model.Name }}s, err := repo.Query(ctx).Find()
{{- if $firstBoolField }}
//   // Get all active {{ lower .Model.Name }}s
//   active{{ .Model.Name }}s, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).Find()
{{- end }}
{{- if $firstStringField }}
//   // Search {{ lower .Model.Name }}s by {{ lower $firstStringField }}
//   matching{{ .Model.Name }}s, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).Find()
{{- end }}
func (q *{{ .Model.Name }}Query) Find() ([]{{ .Model.Name }}, error) {
	return q.Query.Find()
}

// First executes the query and returns the first matching {{ .Model.Name }} record.
// Returns nil if no record is found. Use with OrderBy to get specific record.
//
// Examples:
//   // Get first {{ lower .Model.Name }}
//   first{{ .Model.Name }}, err := repo.Query(ctx).First()
{{- if $firstTimeField }}
//   // Get most recent {{ lower .Model.Name }}
//   latest{{ .Model.Name }}, err := repo.Query(ctx).OrderBy("{{ $firstTimeField }} DESC").First()
{{- end }}
{{- if $firstStringField }}
//   // Get specific {{ lower .Model.Name }} by {{ lower $firstStringField }}
//   specific{{ .Model.Name }}, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Eq("value")).First()
{{- end }}
func (q *{{ .Model.Name }}Query) First() (*{{ .Model.Name }}, error) {
	return q.Query.First()
}

// Count returns the number of {{ .Model.Name }} records matching the query conditions.
// Does not load the actual records, making it efficient for large datasets.
//
// Examples:
//   // Count all {{ lower .Model.Name }}s
//   total, err := repo.Query(ctx).Count()
{{- if $firstBoolField }}
//   // Count active {{ lower .Model.Name }}s
//   activeCount, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).Count()
{{- end }}
{{- if $firstStringField }}
//   // Count {{ lower .Model.Name }}s matching criteria
//   matchingCount, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("%search%")).Count()
{{- end }}
func (q *{{ .Model.Name }}Query) Count() (int64, error) {
	return q.Query.Count()
}

// Exists checks if any {{ .Model.Name }} records match the query conditions.
// Returns true if at least one record exists, false otherwise.
// More efficient than Count() when you only need to know if records exist.
//
// Examples:
//   // Check if any {{ lower .Model.Name }}s exist
//   hasAny, err := repo.Query(ctx).Exists()
{{- if $firstStringField }}
//   // Check if {{ lower .Model.Name }} with specific {{ lower $firstStringField }} exists
//   exists, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Eq("value")).Exists()
{{- end }}
{{- if $firstBoolField }}
//   // Check if any active {{ lower .Model.Name }}s exist
//   hasActive, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(true)).Exists()
{{- end }}
func (q *{{ .Model.Name }}Query) Exists() (bool, error) {
	return q.Query.Exists()
}

// Delete removes all {{ .Model.Name }} records matching the query conditions.
// Returns the number of records deleted.
// WARNING: This is a bulk operation that cannot be undone.
//
// Examples:
//   // Delete all {{ lower .Model.Name }}s (use with caution!)
//   deleted, err := repo.Query(ctx).Delete()
{{- if $firstBoolField }}
//   // Delete inactive {{ lower .Model.Name }}s
//   deleted, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstBoolField }}.Eq(false)).Delete()
{{- end }}
{{- if $firstStringField }}
//   // Delete {{ lower .Model.Name }}s matching criteria
//   deleted, err := repo.Query(ctx).Where({{ .Model.Name }}s.{{ sanitizeGoName $firstStringField }}.Like("temp_%")).Delete()
{{- end }}
func (q *{{ .Model.Name }}Query) Delete() (int64, error) {
	return q.Query.Delete()
}

{{range .Model.Relationships}}
// Include{{ .Name }} includes the {{ .Name }} relationship in the query
// This method can be chained with other query methods
//
// Example:
{{- if eq .Relationship.Type "belongs_to" }}
//   {{ lower $.Model.Name }}s, err := repo.Query(ctx).Include{{ .Name }}().Where(condition).Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} loaded
{{- else if eq .Relationship.Type "has_many" }}
//   {{ lower $.Model.Name }}s, err := repo.Query(ctx).Include{{ .Name }}().Where(condition).Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} slice populated
{{- else if eq .Relationship.Type "has_one" }}
//   {{ lower $.Model.Name }}s, err := repo.Query(ctx).Include{{ .Name }}().Where(condition).Find()
//   // Each {{ $.Model.Name }} will have its {{ .Name }} loaded if it exists
{{- else }}
//   {{ lower $.Model.Name }}s, err := repo.Query(ctx).Include{{ .Name }}().Where(condition).Find()
{{- end }}
func (q *{{ $.Model.Name }}Query) Include{{ .Name }}() *{{ $.Model.Name }}Query {
	q.Query = q.Query.Include("{{ .Name }}")
	return q
}
{{end}}

`

// queryTemplate is now merged with repositoryTemplate - this is kept empty for backwards compatibility
const queryTemplate = `// This template is now merged with the repository template`

// relationshipsTemplate generates relationship helper functions
const relationshipsTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//

package {{ .Package }}

// Relationships are handled by WithXXX methods in repositories
// No additional relationship helpers needed - see repository files for With{{ .Model.Name }} methods
`

// stormTemplate generates the Storm struct with all repositories
const stormTemplate = `//go:build !exclude_generated
// +build !exclude_generated

// Code generated by storm orm generate-orm; DO NOT EDIT.
//
// This file was automatically generated from Go struct definitions.
// Any changes made to this file will be lost when regenerating.
//
// Source package: {{ .Package }}
// Models found: {{ len .Models }}
// Generated on: {{ .Now.Format "2006-01-02 15:04:05 MST" }}
//
// To regenerate this file, run:
//   storm orm generate-orm --package={{ .Package }}
//
// For more information, see:
//   https://github.com/eleven-am/storm

package {{ .Package }}

import (
	"context"
	"fmt"
	storm "github.com/eleven-am/storm/pkg/storm-orm"
	"github.com/jmoiron/sqlx"
)

// Storm provides a centralized access point for all repositories
// 
// Basic usage:
//   storm := NewStorm(db)
//   user, err := storm.Users.FindByID(ctx, "123")
//   users, err := storm.Users.Query(ctx).Where(Users.IsActive.Eq(true)).Find()
//
// All repositories inherit these methods from the base repository:
//
// Single Record Operations:
//   - Create(ctx, record) - Insert single record, returns saved record
//   - FindByID(ctx, id) - Find record by primary key
//   - Update(ctx, record) - Update single record by primary key, returns updated record
//   - Delete(ctx, id) - Delete record by primary key ID, returns deleted record
//   - DeleteRecord(ctx, record) - Delete record using the record instance, returns deleted record
//
// Batch Operations:
//   - CreateMany(ctx, records) - Insert multiple records in transaction
//   - BulkUpdate(ctx, records, opts) - Update multiple records with bulk operation
//   - Upsert(ctx, record, opts) - Insert or update single record on conflict
//   - UpsertMany(ctx, records, opts) - Insert or update multiple records on conflict
//
// Transaction support:
//   err := storm.WithTransaction(ctx, func(txStorm *Storm) error {
//       // All operations here run in a transaction
//       return txStorm.Users.Create(ctx, newUser)
//   })
type Storm struct {
	*storm.Storm
	
	// All repositories
	{{range $modelName, $model := .Models}}
	{{ plural $model.Name }} *{{ $model.Name }}Repository
	{{end}}
}

func NewStorm(db *sqlx.DB, logger ...storm.QueryLogger) *Storm {
	baseStorm := storm.NewStorm(db, logger...)
	
	storm := &Storm{
		Storm: baseStorm,
	}
	
	storm.initializeRepositories()
	
	return storm
}

func (s *Storm) WithTransaction(ctx context.Context, fn func(*Storm) error) error {
	return s.Storm.WithTransaction(ctx, func(baseStorm *storm.Storm) error {
		txStorm := &Storm{
			Storm: baseStorm,
		}
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

func (s *Storm) WithTransactionOptions(ctx context.Context, opts *storm.TransactionOptions, fn func(*Storm) error) error {
	return s.Storm.WithTransactionOptions(ctx, opts, func(baseStorm *storm.Storm) error {
		txStorm := &Storm{
			Storm: baseStorm,
		}
		txStorm.initializeRepositories()
		return fn(txStorm)
	})
}

func (s *Storm) initializeRepositories() {
	executor := s.GetExecutor()
	
	{{range $modelName, $model := .Models}}
	if baseRepo, err := storm.NewRepositoryWithExecutor[{{ $model.Name }}](executor, {{ $model.Name }}Metadata); err == nil {
		s.{{ plural $model.Name }} = &{{ $model.Name }}Repository{
			Repository: baseRepo,
		}
	} else {
		panic(fmt.Errorf("failed to initialize {{ $model.Name }} repository: %w", err))
	}
	{{end}}
}
`
