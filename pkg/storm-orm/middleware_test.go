package orm

import (
	"context"
	"fmt"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test model for middleware tests
type TestUser struct {
	ID        int       `storm:"primary_key,auto_increment" db:"id"`
	Name      string    `storm:"column:name" db:"name"`
	Email     string    `storm:"column:email,unique" db:"email"`
	IsActive  bool      `storm:"column:is_active" db:"is_active"`
	CreatedAt time.Time `storm:"column:created_at,default:now()" db:"created_at"`
	UpdatedAt time.Time `storm:"column:updated_at,default:now()" db:"updated_at"`
}

// Create test metadata for TestUser
func createTestUserMetadata() *ModelMetadata {
	return &ModelMetadata{
		TableName:  "users",
		StructName: "TestUser",
		Columns: map[string]*ColumnMetadata{
			"ID": {
				FieldName:       "ID",
				DBName:          "id",
				GoType:          "int",
				IsPrimaryKey:    true,
				IsAutoGenerated: true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).ID
				},
			},
			"Name": {
				FieldName: "Name",
				DBName:    "name",
				GoType:    "string",
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).Name
				},
			},
			"Email": {
				FieldName: "Email",
				DBName:    "email",
				GoType:    "string",
				IsUnique:  true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).Email
				},
			},
			"IsActive": {
				FieldName: "IsActive",
				DBName:    "is_active",
				GoType:    "bool",
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).IsActive
				},
			},
			"CreatedAt": {
				FieldName:       "CreatedAt",
				DBName:          "created_at",
				GoType:          "time.Time",
				IsAutoGenerated: true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).CreatedAt
				},
			},
			"UpdatedAt": {
				FieldName:       "UpdatedAt",
				DBName:          "updated_at",
				GoType:          "time.Time",
				IsAutoGenerated: true,
				GetValue: func(model interface{}) interface{} {
					return model.(TestUser).UpdatedAt
				},
			},
		},
		ColumnMap: map[string]string{
			"ID":        "id",
			"Name":      "name",
			"Email":     "email",
			"IsActive":  "is_active",
			"CreatedAt": "created_at",
			"UpdatedAt": "updated_at",
		},
		ReverseMap: map[string]string{
			"id":         "ID",
			"name":       "Name",
			"email":      "Email",
			"is_active":  "IsActive",
			"created_at": "CreatedAt",
			"updated_at": "UpdatedAt",
		},
		PrimaryKeys: []string{"id"},
	}
}

// TestMiddlewareUpdateFields tests middleware for UpdateFields operations
func TestMiddlewareUpdateFields(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpUpdate {
				if updateBuilder, ok := ctx.QueryBuilder.(squirrel.UpdateBuilder); ok {

					ctx.QueryBuilder = updateBuilder.Set("updated_by", "middleware")
				}
			}
			return next(ctx)
		}
	})

	userID := 1
	now := time.Now()
	updates := map[string]interface{}{
		"name": "Updated Name",
	}

	mock.ExpectQuery(`SELECT .* FROM users WHERE id = \$1`).
		WithArgs(userID).
		WillReturnRows(sqlmock.NewRows([]string{"id", "name", "email", "is_active", "created_at", "updated_at"}).
			AddRow(userID, "Old Name", "old@example.com", true, now, now))

	mock.ExpectExec(`UPDATE users SET`).
		WithArgs("Updated Name", "middleware", userID).
		WillReturnResult(sqlmock.NewResult(0, 1))

	mock.ExpectQuery(`SELECT .* FROM users WHERE id = \$1`).
		WithArgs(userID).
		WillReturnRows(sqlmock.NewRows([]string{"id", "name", "email", "is_active", "created_at", "updated_at"}).
			AddRow(userID, "Updated Name", "old@example.com", true, now, now))

	user, err := repo.UpdateFields(context.Background(), userID, updates)
	require.NoError(t, err)
	require.NotNil(t, user)

	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareDelete tests middleware for Delete operations
func TestMiddlewareDelete(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpDelete {

				return fmt.Errorf("deletion not allowed")
			}
			return next(ctx)
		}
	})

	_, err = repo.Delete(context.Background(), 1)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "deletion not allowed")

	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareErrorHandling tests error handling in middleware
func TestMiddlewareErrorHandling(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpCreate {
				return fmt.Errorf("create operation blocked by middleware")
			}
			return next(ctx)
		}
	})

	user := &TestUser{Name: "Test", Email: "test@example.com"}
	_, err = repo.Create(context.Background(), user)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "create operation blocked by middleware")

	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareCount tests middleware for Count operations with flexible SQL matching
func TestMiddlewareCount(t *testing.T) {
	db, mock, err := sqlmock.New(sqlmock.QueryMatcherOption(sqlmock.QueryMatcherFunc(func(expectedSQL, actualSQL string) error {

		assert.Contains(t, actualSQL, "is_active")
		assert.Contains(t, actualSQL, "tenant_id")
		assert.Contains(t, actualSQL, "COUNT(*)")
		return nil
	})))
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			if ctx.Operation == OpQuery {
				if selectBuilder, ok := ctx.QueryBuilder.(squirrel.SelectBuilder); ok {

					ctx.QueryBuilder = selectBuilder.Where(squirrel.Eq{"tenant_id": 123})
				}
			}
			return next(ctx)
		}
	})

	mock.ExpectQuery("SELECT COUNT").
		WillReturnRows(sqlmock.NewRows([]string{"count"}).AddRow(5))

	activeCol := Column[bool]{Name: "is_active", Table: "users"}
	query := repo.Query(context.Background()).Where(activeCol.Eq(true))
	count, err := query.Count()
	require.NoError(t, err)
	assert.Equal(t, int64(5), count)

	require.NoError(t, mock.ExpectationsWereMet())
}

// TestMiddlewareUpdateMany tests middleware for UpdateMany operations with Action system
func TestMiddlewareUpdateMany(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "postgres")
	metadata := createTestUserMetadata()

	repo, err := NewRepository[TestUser](sqlxDB, metadata)
	require.NoError(t, err)

	middlewareCalled := false
	repo.AddMiddleware(func(next QueryMiddlewareFunc) QueryMiddlewareFunc {
		return func(ctx *MiddlewareContext) error {
			middlewareCalled = true
			assert.Equal(t, OpUpdateMany, ctx.Operation)
			assert.Equal(t, "users", ctx.TableName)

			return next(ctx)
		}
	})

	mock.ExpectExec(`UPDATE users SET is_active = \$1 WHERE \(users\.name LIKE \$2\)`).
		WithArgs(false, "test%").
		WillReturnResult(sqlmock.NewResult(0, 3))

	isActiveCol := Column[bool]{Name: "is_active", Table: "users"}
	nameCol := StringColumn{Column: Column[string]{Name: "name", Table: "users"}}
	condition := nameCol.Like("test%")
	rowsAffected, err := repo.Query(context.Background()).Where(condition).Update(
		isActiveCol.Set(false),
	)
	require.NoError(t, err)
	assert.Equal(t, int64(3), rowsAffected)
	assert.True(t, middlewareCalled, "Middleware should have been called")

	require.NoError(t, mock.ExpectationsWereMet())
}
