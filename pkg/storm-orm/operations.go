package orm

import (
	"context"
	"fmt"
	"strings"

	"github.com/Masterminds/squirrel"
	"github.com/jmoiron/sqlx"
)

// UpsertOptions configures upsert behavior
type UpsertOptions struct {
	ConflictColumns []string          // Columns that define conflicts (ON CONFLICT)
	UpdateColumns   []string          // Columns to update on conflict (if empty, updates all non-conflict columns)
	UpdateExpr      map[string]string // Custom update expressions (column -> expression)
}

func (r *Repository[T]) Create(ctx context.Context, record *T) (*T, error) {
	if record == nil {
		return nil, &Error{
			Op:    "create",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	columns, values := r.getInsertFields(*record)
	if len(columns) == 0 {
		return nil, &Error{
			Op:    "create",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("no fields to insert"),
		}
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...).
		Values(values...)

	err := r.executeQueryMiddleware(OpCreate, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		returningCols := r.getAutoGeneratedColumns()

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "create",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		if len(returningCols) > 0 {
			sqlQuery += " RETURNING " + strings.Join(returningCols, ", ")
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		var execErr error
		if len(returningCols) > 0 {
			if err := r.db.GetContext(ctx, record, sqlQuery, args...); err != nil {
				execErr = err
			}
		} else {
			if _, err := r.db.ExecContext(ctx, sqlQuery, args...); err != nil {
				execErr = err
			}
		}

		if execErr != nil {
			return parsePostgreSQLError(execErr, "create", r.metadata.TableName)
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return record, nil
}

func (r *Repository[T]) FindByID(ctx context.Context, id interface{}) (*T, error) {
	if len(r.metadata.PrimaryKeys) != 1 {
		return nil, &Error{
			Op:    "findByID",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	selectColumns := make([]string, 0, len(r.metadata.Columns))
	for _, col := range r.metadata.Columns {
		selectColumns = append(selectColumns, col.DBName)
	}

	query := squirrel.Select(selectColumns...).
		From(r.metadata.TableName).
		Where(squirrel.Eq{r.metadata.PrimaryKeys[0]: id}).
		PlaceholderFormat(squirrel.Dollar).
		Limit(1)

	sqlQuery, args, err := query.ToSql()
	if err != nil {
		return nil, &Error{
			Op:    "findByID",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("failed to build query: %w", err),
		}
	}

	var record T
	err = r.db.GetContext(ctx, &record, sqlQuery, args...)
	if err != nil {
		return nil, parsePostgreSQLError(err, "findByID", r.metadata.TableName)
	}

	return &record, nil
}

func (r *Repository[T]) Update(ctx context.Context, record *T) (*T, error) {
	if record == nil {
		return nil, &Error{
			Op:    "update",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	query := squirrel.Update(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar)

	updateFields := r.getUpdateFields(*record)
	for column, value := range updateFields {
		query = query.Set(column, value)
	}

	pkValues := r.getPrimaryKeyValues(*record)
	for pkCol, value := range pkValues {
		query = query.Where(squirrel.Eq{pkCol: value})
	}

	err := r.executeQueryMiddleware(OpUpdate, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.UpdateBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "update",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "update", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "update",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return record, nil
}

// UpdateFields updates specific fields of a single record by primary key
func (r *Repository[T]) UpdateFields(ctx context.Context, id interface{}, updates map[string]interface{}) (*T, error) {
	if len(r.metadata.PrimaryKeys) != 1 {
		return nil, &Error{
			Op:    "updateFields",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	if len(updates) == 0 {
		return nil, &Error{
			Op:    "updateFields",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("no updates provided"),
		}
	}

	query := squirrel.Update(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Where(squirrel.Eq{r.metadata.PrimaryKeys[0]: id})

	for column, value := range updates {
		query = query.Set(column, value)
	}

	var record *T

	err := r.executeQueryMiddleware(OpUpdate, ctx, updates, query, func(middlewareCtx *MiddlewareContext) error {

		var err error
		record, err = r.FindByID(ctx, id)
		if err != nil {
			return err
		}

		finalQuery := middlewareCtx.QueryBuilder.(squirrel.UpdateBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "updateFields",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "updateFields", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "updateFields",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		record, err = r.FindByID(ctx, id)
		if err != nil {
			return err
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return record, nil
}

func (r *Repository[T]) Delete(ctx context.Context, id interface{}) (*T, error) {
	if len(r.metadata.PrimaryKeys) != 1 {
		return nil, &Error{
			Op:    "delete",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("composite primary keys not supported"),
		}
	}

	query := squirrel.Delete(r.metadata.TableName).
		Where(squirrel.Eq{r.metadata.PrimaryKeys[0]: id}).
		PlaceholderFormat(squirrel.Dollar)

	var record *T

	err := r.executeQueryMiddleware(OpDelete, ctx, id, query, func(middlewareCtx *MiddlewareContext) error {

		var err error
		record, err = r.FindByID(ctx, id)
		if err != nil {
			return err
		}

		finalQuery := middlewareCtx.QueryBuilder.(squirrel.DeleteBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "delete",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "delete", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "delete",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return record, nil
}

func (r *Repository[T]) DeleteRecord(ctx context.Context, record *T) (*T, error) {
	if record == nil {
		return nil, &Error{
			Op:    "deleteRecord",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	query := squirrel.Delete(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar)

	pkValues := r.getPrimaryKeyValues(*record)
	for pkCol, value := range pkValues {
		query = query.Where(squirrel.Eq{pkCol: value})
	}

	err := r.executeQueryMiddleware(OpDelete, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.DeleteBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "deleteRecord",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		result, err := r.db.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "deleteRecord", r.metadata.TableName)
		}

		rowsAffected, err := result.RowsAffected()
		if err != nil {
			return &Error{
				Op:    "deleteRecord",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to get rows affected: %w", err),
			}
		}

		if rowsAffected == 0 {
			return ErrNotFound
		}

		return nil
	})

	if err != nil {
		return nil, err
	}

	return record, nil
}

func (r *Repository[T]) CreateMany(ctx context.Context, records []T) error {
	if len(records) == 0 {
		return nil
	}

	var executor DBExecutor
	needsCommit := false
	var rollback func()

	if _, isTransaction := r.db.(*sqlx.Tx); isTransaction {
		executor = r.db
	} else {
		db := r.db.(*sqlx.DB)
		tx, err := db.BeginTxx(ctx, nil)
		if err != nil {
			return &Error{
				Op:    "createMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to begin transaction: %w", err),
			}
		}
		rollback = func() {
			if rbErr := tx.Rollback(); rbErr != nil && rbErr.Error() != "sql: transaction has already been committed or rolled back" {

			}
		}
		executor = tx
		needsCommit = true
	}

	defer func() {
		if rollback != nil {
			rollback()
		}
	}()

	var columns []string
	if len(records) > 0 {
		columns, _ = r.getInsertFields(records[0])
	}

	if len(columns) == 0 {
		return nil
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...)

	for _, record := range records {
		_, values := r.getInsertFields(record)
		query = query.Values(values...)
	}

	return r.executeQueryMiddleware(OpCreateMany, ctx, records, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "createMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build batch insert query: %w", err),
			}
		}

		middlewareCtx.Query = sqlQuery
		middlewareCtx.Args = args

		_, err = executor.ExecContext(ctx, sqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "createMany", r.metadata.TableName)
		}

		if needsCommit {
			tx := executor.(*sqlx.Tx)
			if err := tx.Commit(); err != nil {
				return &Error{
					Op:    "createMany",
					Table: r.metadata.TableName,
					Err:   fmt.Errorf("failed to commit transaction: %w", err),
				}
			}
			rollback = nil
		}

		return nil
	})
}

func (r *Repository[T]) Upsert(ctx context.Context, record *T, opts UpsertOptions) error {
	if record == nil {
		return &Error{
			Op:    "upsert",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("record cannot be nil"),
		}
	}

	if len(opts.ConflictColumns) == 0 {
		return &Error{
			Op:    "upsert",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("conflict columns must be specified"),
		}
	}

	columns, values := r.getInsertFields(*record)
	if len(columns) == 0 {
		return &Error{
			Op:    "upsert",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("no fields to insert"),
		}
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...).
		Values(values...)

	return r.executeQueryMiddleware(OpUpsert, ctx, record, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "upsert",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build insert query: %w", err),
			}
		}

		onConflict := fmt.Sprintf(" ON CONFLICT (%s)", strings.Join(opts.ConflictColumns, ", "))

		var updateColumns []string
		if len(opts.UpdateColumns) > 0 {
			updateColumns = opts.UpdateColumns
		} else {
			conflictSet := make(map[string]bool)
			for _, col := range opts.ConflictColumns {
				conflictSet[col] = true
			}

			for _, col := range columns {
				if !conflictSet[col] {
					updateColumns = append(updateColumns, col)
				}
			}
		}

		if len(updateColumns) > 0 {
			var setParts []string
			for _, col := range updateColumns {
				if expr, hasCustom := opts.UpdateExpr[col]; hasCustom {
					setParts = append(setParts, fmt.Sprintf("%s = %s", col, expr))
				} else {
					setParts = append(setParts, fmt.Sprintf("%s = EXCLUDED.%s", col, col))
				}
			}
			onConflict += " DO UPDATE SET " + strings.Join(setParts, ", ")
		} else {
			onConflict += " DO NOTHING"
		}

		finalSqlQuery := sqlQuery + onConflict

		middlewareCtx.Query = finalSqlQuery
		middlewareCtx.Args = args

		_, err = r.db.ExecContext(ctx, finalSqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "upsert", r.metadata.TableName)
		}

		return nil
	})
}

func (r *Repository[T]) UpsertMany(ctx context.Context, records []T, opts UpsertOptions) error {
	if len(records) == 0 {
		return nil
	}

	if len(opts.ConflictColumns) == 0 {
		return &Error{
			Op:    "upsertMany",
			Table: r.metadata.TableName,
			Err:   fmt.Errorf("conflict columns must be specified"),
		}
	}

	var executor DBExecutor
	needsCommit := false
	var rollback func()

	if _, isTransaction := r.db.(*sqlx.Tx); isTransaction {
		executor = r.db
	} else {
		db := r.db.(*sqlx.DB)
		tx, err := db.BeginTxx(ctx, nil)
		if err != nil {
			return &Error{
				Op:    "upsertMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to begin transaction: %w", err),
			}
		}
		rollback = func() {
			if rbErr := tx.Rollback(); rbErr != nil && rbErr.Error() != "sql: transaction has already been committed or rolled back" {

			}
		}
		executor = tx
		needsCommit = true
	}

	defer func() {
		if rollback != nil {
			rollback()
		}
	}()

	var columns []string
	if len(records) > 0 {
		columns, _ = r.getInsertFields(records[0])
	}

	if len(columns) == 0 {
		return nil
	}

	query := squirrel.Insert(r.metadata.TableName).
		PlaceholderFormat(squirrel.Dollar).
		Columns(columns...)

	for _, record := range records {
		_, values := r.getInsertFields(record)
		query = query.Values(values...)
	}

	return r.executeQueryMiddleware(OpUpsertMany, ctx, records, query, func(middlewareCtx *MiddlewareContext) error {
		finalQuery := middlewareCtx.QueryBuilder.(squirrel.InsertBuilder)

		sqlQuery, args, err := finalQuery.ToSql()
		if err != nil {
			return &Error{
				Op:    "upsertMany",
				Table: r.metadata.TableName,
				Err:   fmt.Errorf("failed to build batch insert query: %w", err),
			}
		}

		onConflict := fmt.Sprintf(" ON CONFLICT (%s)", strings.Join(opts.ConflictColumns, ", "))
		var updateColumns []string
		if len(opts.UpdateColumns) > 0 {
			updateColumns = opts.UpdateColumns
		} else {
			conflictSet := make(map[string]bool)
			for _, col := range opts.ConflictColumns {
				conflictSet[col] = true
			}

			for _, col := range columns {
				if !conflictSet[col] {
					updateColumns = append(updateColumns, col)
				}
			}
		}

		if len(updateColumns) > 0 {
			var setParts []string
			for _, col := range updateColumns {
				if expr, hasCustom := opts.UpdateExpr[col]; hasCustom {
					setParts = append(setParts, fmt.Sprintf("%s = %s", col, expr))
				} else {
					setParts = append(setParts, fmt.Sprintf("%s = EXCLUDED.%s", col, col))
				}
			}
			onConflict += " DO UPDATE SET " + strings.Join(setParts, ", ")
		} else {
			onConflict += " DO NOTHING"
		}

		finalSqlQuery := sqlQuery + onConflict

		middlewareCtx.Query = finalSqlQuery
		middlewareCtx.Args = args

		_, err = executor.ExecContext(ctx, finalSqlQuery, args...)
		if err != nil {
			return parsePostgreSQLError(err, "upsertMany", r.metadata.TableName)
		}

		if needsCommit {
			tx := executor.(*sqlx.Tx)
			if err := tx.Commit(); err != nil {
				return &Error{
					Op:    "upsertMany",
					Table: r.metadata.TableName,
					Err:   fmt.Errorf("failed to commit transaction: %w", err),
				}
			}
			rollback = nil
		}

		return nil
	})
}
