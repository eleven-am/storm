package orm

import (
	"context"
	"database/sql"
	"reflect"
	"testing"
	"time"

	"github.com/DATA-DOG/go-sqlmock"
	"github.com/jmoiron/sqlx"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestRelationshipManager(t *testing.T) {
	t.Run("newRelationshipManager", func(t *testing.T) {
		mgr := newRelationshipManager("users")
		assert.NotNil(t, mgr)
		assert.NotNil(t, mgr.relationships)
		assert.Equal(t, "users", mgr.sourceTable)
	})

	t.Run("parseRelationships empty struct", func(t *testing.T) {
		type EmptyModel struct {
			ID int64
		}
		mgr := newRelationshipManager("users")
		modelType := reflect.TypeOf(EmptyModel{})
		err := mgr.parseRelationships(modelType)
		assert.NoError(t, err)
		assert.False(t, mgr.hasRelationships())
	})

	t.Run("getRelationships", func(t *testing.T) {
		mgr := newRelationshipManager("users")
		mgr.relationships["posts"] = relationshipDef{
			FieldName: "Posts",
			Type:      "has_many",
		}
		mgr.relationships["user"] = relationshipDef{
			FieldName: "User",
			Type:      "belongs_to",
		}

		rels := mgr.getRelationships()
		assert.Len(t, rels, 2)
	})

	t.Run("getRelationship", func(t *testing.T) {
		mgr := newRelationshipManager("users")
		expectedRel := relationshipDef{
			FieldName: "Posts",
			Type:      "has_many",
		}
		mgr.relationships["posts"] = expectedRel

		rel := mgr.getRelationship("posts")
		assert.NotNil(t, rel)
		assert.Equal(t, expectedRel, *rel)

		rel = mgr.getRelationship("comments")
		assert.Nil(t, rel)
	})

	t.Run("hasRelationships", func(t *testing.T) {
		mgr := newRelationshipManager("users")
		assert.False(t, mgr.hasRelationships())

		mgr.relationships["posts"] = relationshipDef{
			FieldName: "Posts",
			Type:      "has_many",
		}
		assert.True(t, mgr.hasRelationships())
	})

}

// Test models for relationship loading
type RelTestUser struct {
	ID        int64     `db:"id" storm:"column:id;type:bigint;primary_key"`
	Name      string    `db:"name" storm:"column:name;type:varchar(100);not_null"`
	Email     string    `db:"email" storm:"column:email;type:varchar(255);not_null"`
	CreatedAt time.Time `db:"created_at" storm:"column:created_at;type:timestamptz;not_null"`

	// Relationships
	Profile *RelTestProfile `storm:"relation:has_one:RelTestProfile;foreign_key:user_id;source_key:id"`
	Posts   []RelTestPost   `storm:"relation:has_many:RelTestPost;foreign_key:user_id;source_key:id"`
}

type RelTestProfile struct {
	ID     int64  `db:"id" storm:"column:id;type:bigint;primary_key"`
	UserID int64  `db:"user_id" storm:"column:user_id;type:bigint;not_null"`
	Bio    string `db:"bio" storm:"column:bio;type:text"`

	// Relationships
	User *RelTestUser `storm:"relation:belongs_to:RelTestUser;foreign_key:user_id;target_key:id"`
}

type RelTestPost struct {
	ID        int64     `db:"id" storm:"column:id;type:bigint;primary_key"`
	UserID    int64     `db:"user_id" storm:"column:user_id;type:bigint;not_null"`
	Title     string    `db:"title" storm:"column:title;type:varchar(255);not_null"`
	Content   string    `db:"content" storm:"column:content;type:text"`
	CreatedAt time.Time `db:"created_at" storm:"column:created_at;type:timestamptz;not_null"`

	// Relationships
	User *RelTestUser `storm:"relation:belongs_to:RelTestUser;foreign_key:user_id;target_key:id"`
}

// Create test metadata with ScanToModel functions
var RelTestUserMetadata = &ModelMetadata{
	TableName:  "users",
	StructName: "RelTestUser",
	Columns: map[string]*ColumnMetadata{
		"ID": {
			FieldName:       "ID",
			DBName:          "id",
			GoType:          "int64",
			IsPrimaryKey:    true,
			IsAutoGenerated: true,
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestUser).ID
			},
		},
		"Name": {
			FieldName: "Name",
			DBName:    "name",
			GoType:    "string",
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestUser).Name
			},
		},
		"Email": {
			FieldName: "Email",
			DBName:    "email",
			GoType:    "string",
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestUser).Email
			},
		},
		"CreatedAt": {
			FieldName: "CreatedAt",
			DBName:    "created_at",
			GoType:    "time.Time",
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestUser).CreatedAt
			},
		},
	},
	PrimaryKeys: []string{"id"},
	Relationships: map[string]*RelationshipMetadata{
		"Profile": {
			Name:       "Profile",
			Type:       "has_one",
			Target:     "RelTestProfile",
			ForeignKey: "UserID",
			SourceKey:  "ID",
			ScanToModel: func(ctx context.Context, exec DBExecutor, query string, args []interface{}, model interface{}) error {
				var profile RelTestProfile
				err := exec.GetContext(ctx, &profile, query, args...)
				if err != nil {
					if err == sql.ErrNoRows {
						return nil // has_one can be nil
					}
					return err
				}
				model.(*RelTestUser).Profile = &profile
				return nil
			},
		},
		"Posts": {
			Name:       "Posts",
			Type:       "has_many",
			Target:     "RelTestPost",
			ForeignKey: "UserID",
			SourceKey:  "ID",
			ScanToModel: func(ctx context.Context, exec DBExecutor, query string, args []interface{}, model interface{}) error {
				var posts []RelTestPost
				err := exec.SelectContext(ctx, &posts, query, args...)
				if err != nil {
					return err
				}
				model.(*RelTestUser).Posts = posts
				return nil
			},
		},
	},
}

var RelTestProfileMetadata = &ModelMetadata{
	TableName:  "profiles",
	StructName: "RelTestProfile",
	Columns: map[string]*ColumnMetadata{
		"ID": {
			FieldName:       "ID",
			DBName:          "id",
			GoType:          "int64",
			IsPrimaryKey:    true,
			IsAutoGenerated: true,
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestProfile).ID
			},
		},
		"UserID": {
			FieldName: "UserID",
			DBName:    "user_id",
			GoType:    "int64",
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestProfile).UserID
			},
		},
		"Bio": {
			FieldName: "Bio",
			DBName:    "bio",
			GoType:    "string",
			GetValue: func(model interface{}) interface{} {
				return model.(RelTestProfile).Bio
			},
		},
	},
	PrimaryKeys: []string{"id"},
	Relationships: map[string]*RelationshipMetadata{
		"User": {
			Name:       "User",
			Type:       "belongs_to",
			Target:     "RelTestUser",
			ForeignKey: "UserID",
			TargetKey:  "ID",
			ScanToModel: func(ctx context.Context, exec DBExecutor, query string, args []interface{}, model interface{}) error {
				var user RelTestUser
				err := exec.GetContext(ctx, &user, query, args...)
				if err != nil {
					return err
				}
				model.(*RelTestProfile).User = &user
				return nil
			},
		},
	},
}

func TestRelationshipLoading_BelongsTo(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "sqlmock")
	repo, err := NewRepository[RelTestProfile](sqlxDB, RelTestProfileMetadata)
	require.NoError(t, err)

	ctx := context.Background()

	profileRows := sqlmock.NewRows([]string{"id", "user_id", "bio"}).
		AddRow(1, 100, "Software Engineer")

	mock.ExpectQuery("SELECT (.+) FROM profiles").
		WillReturnRows(profileRows)

	userRows := sqlmock.NewRows([]string{"id", "name", "email", "created_at"}).
		AddRow(100, "John Doe", "john@example.com", time.Now())

	mock.ExpectQuery("SELECT (.+) FROM RelTestUser WHERE ID = ?").
		WithArgs(100).
		WillReturnRows(userRows)

	profiles, err := repo.Query(ctx).Include("User").Find()
	require.NoError(t, err)
	require.Len(t, profiles, 1)

	profile := profiles[0]
	assert.Equal(t, int64(1), profile.ID)
	assert.Equal(t, int64(100), profile.UserID)
	assert.Equal(t, "Software Engineer", profile.Bio)

	require.NotNil(t, profile.User)
	assert.Equal(t, int64(100), profile.User.ID)
	assert.Equal(t, "John Doe", profile.User.Name)
	assert.Equal(t, "john@example.com", profile.User.Email)

	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestRelationshipLoading_HasOne(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "sqlmock")
	repo, err := NewRepository[RelTestUser](sqlxDB, RelTestUserMetadata)
	require.NoError(t, err)

	ctx := context.Background()

	userRows := sqlmock.NewRows([]string{"id", "name", "email", "created_at"}).
		AddRow(100, "John Doe", "john@example.com", time.Now())

	mock.ExpectQuery("SELECT (.+) FROM users").
		WillReturnRows(userRows)

	profileRows := sqlmock.NewRows([]string{"id", "user_id", "bio"}).
		AddRow(1, 100, "Software Engineer")

	mock.ExpectQuery("SELECT (.+) FROM RelTestProfile WHERE UserID = ?").
		WithArgs(100).
		WillReturnRows(profileRows)

	users, err := repo.Query(ctx).Include("Profile").Find()
	require.NoError(t, err)
	require.Len(t, users, 1)

	user := users[0]
	assert.Equal(t, int64(100), user.ID)
	assert.Equal(t, "John Doe", user.Name)
	assert.Equal(t, "john@example.com", user.Email)

	require.NotNil(t, user.Profile)
	assert.Equal(t, int64(1), user.Profile.ID)
	assert.Equal(t, int64(100), user.Profile.UserID)
	assert.Equal(t, "Software Engineer", user.Profile.Bio)

	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestRelationshipLoading_HasMany(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "sqlmock")
	repo, err := NewRepository[RelTestUser](sqlxDB, RelTestUserMetadata)
	require.NoError(t, err)

	ctx := context.Background()

	userRows := sqlmock.NewRows([]string{"id", "name", "email", "created_at"}).
		AddRow(100, "John Doe", "john@example.com", time.Now())

	mock.ExpectQuery("SELECT (.+) FROM users").
		WillReturnRows(userRows)

	now := time.Now()
	postRows := sqlmock.NewRows([]string{"id", "user_id", "title", "content", "created_at"}).
		AddRow(1, 100, "First Post", "This is my first post", now).
		AddRow(2, 100, "Second Post", "This is my second post", now)

	mock.ExpectQuery("SELECT (.+) FROM RelTestPost WHERE UserID = ?").
		WithArgs(100).
		WillReturnRows(postRows)

	users, err := repo.Query(ctx).Include("Posts").Find()
	require.NoError(t, err)
	require.Len(t, users, 1)

	user := users[0]
	assert.Equal(t, int64(100), user.ID)
	assert.Equal(t, "John Doe", user.Name)
	assert.Equal(t, "john@example.com", user.Email)

	require.Len(t, user.Posts, 2)

	assert.Equal(t, int64(1), user.Posts[0].ID)
	assert.Equal(t, int64(100), user.Posts[0].UserID)
	assert.Equal(t, "First Post", user.Posts[0].Title)
	assert.Equal(t, "This is my first post", user.Posts[0].Content)

	assert.Equal(t, int64(2), user.Posts[1].ID)
	assert.Equal(t, int64(100), user.Posts[1].UserID)
	assert.Equal(t, "Second Post", user.Posts[1].Title)
	assert.Equal(t, "This is my second post", user.Posts[1].Content)

	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestScanToModel_BelongsTo(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "sqlmock")
	ctx := context.Background()

	profile := &RelTestProfile{
		ID:     1,
		UserID: 100,
		Bio:    "Software Engineer",
	}

	userRows := sqlmock.NewRows([]string{"id", "name", "email", "created_at"}).
		AddRow(100, "John Doe", "john@example.com", time.Now())

	mock.ExpectQuery("SELECT (.+) FROM RelTestUser WHERE ID = ?").
		WithArgs(100).
		WillReturnRows(userRows)

	userRelationship := RelTestProfileMetadata.Relationships["User"]
	require.NotNil(t, userRelationship)

	err = userRelationship.ScanToModel(ctx, sqlxDB, "SELECT id, name, email, created_at FROM RelTestUser WHERE ID = ?", []interface{}{100}, profile)
	require.NoError(t, err)

	require.NotNil(t, profile.User)
	assert.Equal(t, int64(100), profile.User.ID)
	assert.Equal(t, "John Doe", profile.User.Name)
	assert.Equal(t, "john@example.com", profile.User.Email)

	assert.NoError(t, mock.ExpectationsWereMet())
}

func TestScanToModel_HasMany(t *testing.T) {
	db, mock, err := sqlmock.New()
	require.NoError(t, err)
	defer db.Close()

	sqlxDB := sqlx.NewDb(db, "sqlmock")
	ctx := context.Background()

	user := &RelTestUser{
		ID:    100,
		Name:  "John Doe",
		Email: "john@example.com",
	}

	now := time.Now()
	postRows := sqlmock.NewRows([]string{"id", "user_id", "title", "content", "created_at"}).
		AddRow(1, 100, "First Post", "This is my first post", now).
		AddRow(2, 100, "Second Post", "This is my second post", now)

	mock.ExpectQuery("SELECT (.+) FROM RelTestPost WHERE UserID = ?").
		WithArgs(100).
		WillReturnRows(postRows)

	postsRelationship := RelTestUserMetadata.Relationships["Posts"]
	require.NotNil(t, postsRelationship)

	err = postsRelationship.ScanToModel(ctx, sqlxDB, "SELECT id, user_id, title, content, created_at FROM RelTestPost WHERE UserID = ?", []interface{}{100}, user)
	require.NoError(t, err)

	require.Len(t, user.Posts, 2)

	assert.Equal(t, int64(1), user.Posts[0].ID)
	assert.Equal(t, int64(100), user.Posts[0].UserID)
	assert.Equal(t, "First Post", user.Posts[0].Title)
	assert.Equal(t, "This is my first post", user.Posts[0].Content)

	assert.Equal(t, int64(2), user.Posts[1].ID)
	assert.Equal(t, int64(100), user.Posts[1].UserID)
	assert.Equal(t, "Second Post", user.Posts[1].Title)
	assert.Equal(t, "This is my second post", user.Posts[1].Content)

	assert.NoError(t, mock.ExpectationsWereMet())
}

// parseRelationshipTag is not exported, so we can't test it directly.
// The relationship parsing is tested indirectly through the repository tests.
